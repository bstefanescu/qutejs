# Overview

A Qute application is composed of two layers:

1. The presentation layer - also known as the **Component Model**
2. The application layer - also known as the **Application Model**

When developing basic UI components you will mostly use the **presentation layer**. And you can completely ignore the **application layer**.  \
When developing more complex components or javascript applications you will need to focus more on the application layer (i.e. **business logic and data**), and less on individual components composing the presentation layer.

The **goal** of Qute is to let you **focus where you need to**. Qute model try to be as concise as possible in order to hide repetitive and glue code.  \
So, you finally write less code and focus more on the business logic.


## The Component Model

When writing web sites one of the most repetitive, annoying and time consuming tasks is to write a lot of similar HTML fragments. To address this, you usually use some template engine, to be able to package these similar HTML fragments as reusable blocks, usually known as **HTML templates**.

### Qute Templates

A template won't be so useful to render only static content. You usually want to parametrize the template content so that, when rendering the template in a specified context, the output will be different depending on that context.

The context in which a template is rendered is providing a **data model** to the template, to resolve the parameters it contains.

Technically, a **template** is a **rendering function** which will generate some HTML given a **rendering context**.  \
You can create templates by simply writing a rendering function from scratch. But, this is not the goal of a template engine. A template must be as easy to write as an HTML fragment. Templates are usually defined using HTML with some additional constructs which is known as the **template language**. The template rendering function will be generated by using a **template compiler**.

Some templates are complex, they not only require some **data model** from the rendering context to resolve template parameters, they also need to define some custom logic. **ViewModel Components** are introduced to solve these cases: a **ViewModel component** defines both the template and the rendering context.

In Qute the **template language** name is **`JSQ`**. `JSQ` provides built-in tag and attribute directives like `<for>`, `<if>`, `<a q:show={isVisible}>`, curly braces for attribute expressions and double curly braces (aka mustached) for content expressions. Example:

```jsq-norun
<a href={href} q:show={isVisible}>{{label}}</a>
```

### Qute Components

As we've seen above, in Qute we have 3 **renderable** entities which make up the **Qute Component Model**:

+ **Pure rendering functions**
+ **Templates**
+ **ViewModel Components**

Any of these three entities can be referenced in Qute templates. We will refer to these entities, as **Qute components**.

Thus, Qute **components** are JavaScript functions or object instances that can be referenced as **custom elements** inside Qute **templates**.

#### The Component's Element Name

The name of a custom element refering to a Qute component is inferred from the component javascript identifier. You can use for the custom element name either the (case sensitive) **javascript identifier** as is, either use its **kebab case** equivalent.

To avoid conflicts with existing (or future) HTML elements the Qute component identifiers must contains **at least an uppercase letter** (i.e. either **camel case** or **pascal case** names). Examples: `myButton`, `MyButton`.

If you prefer to use **HTML compliant** element names you can convert pascal case identifiers to kebab case names. Example: `MyButton` to `my-button`. If the identifier is in camel case (starts with a lowercase letter) then the first kebab name segment becomes the element prefix. Example: `myButton` to `my:button`.  \
Identifiers in pascal case name can use the default prefix **`c:`** (`c` from component).

**Examples:**

+ The identifier `myPrimaryButton` can be used in templates either as `<myPrimaryButton>` or as `<my:primary-button>`.
+ The identifier `MyPrimaryButton` can be used in templates either as `<MyPrimaryButton>`, either as `<my-primary-button>`.or as `<c:my-primary-button>`.
+ The identifier `Button` can be used in templates either as `<Button>` or as `<c:button>`.

**Note:** For the rest of the documentation we will mostly use the **kebab case** notation for component element names.

Let's see an example of each type of a Qute component:

#### Pure Rendering functions

```jsq
// the pure rendering function component
function AboutLink(ctx) {
    var link = document.createElement('A');
    link.textContent = 'About';
    link.href = '#about';
    return link;
}

// the root component
<q:template export>
    <div>
        <div>Using identifier case: <AboutLink /></div>
        <div>Using kebab case: <about-link /></div>
    </div>
</q:template>
```

#### Templates

Templates are rendering functions generated from an HTML like fragment by the Qute compiler. Template are declared inside `.jsq` (or `.qute`) files and should be enclosed in a `<q:template>` tag:

```jsq
// The MyLink component
<q:template name='MyLink'>
    <a href={href}>{{$attrs.label}}</a>
</q:template>

// The root component
<q:template export>
    <div>
        <div>Using identifier case: <MyLink href='about' label='About'/></div>
        <div>Using kebab case: <my-link href='about' label='About'/></div>
    </div>
</q:template>
```

#### ViewModel Components

A ViewModel component is defining a rendering context  (i.e. a rendering data model and logic), and a rendering function to be used to render the component. The rendering function can be either a **pure rendering function**, either a **template**.  will link a template (or a pure rendering function) to a rendering context (i.e. rendering data model and logic).

For a better code clarity, **Qute `ViewModel` components** are defined using JavaScript **[classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)** and **[decorators](https://github.com/tc39/proposal-decorators)**. Qute also provides an API to define components using ES5 syntax but it is more verbose. In this documentation we will focus on the class and decorators syntax. Decorators are not part of the ES6 syntax and are transpiled to ES5 code by the Qute compiler.

ViewModel components can be declared in the same `.jsq` file as the linked template or in a regular javascript file and then importing the template via a javascript `import` statement.

```jsq
import Qute from '@qutejs/runtime';
const { ViewModel, Template, Property } = Qute;

// The MyLink template
<q:template name='MyLinkTemplate'>
    <a href={href} @click='handleClick'>{{label}}</a>
</q:template>

// The ViewModel component
@Template(MyLinkTemplate)
class MyLink extends ViewModel {

    @Property(String) href;

    @Property(String) label;

    handleClick() {
        alert('Hello!');
    }

}

// The root component
<q:template export>
    <div>
        <div>Using identifier case: <MyLink href='#about' label='About'/></div>
        <div>Using kebab case: <my-link href='#about' label='About'/></div>
    </div>
</q:template>
```

In the above example we defined a `MyLink` ViewModel component with two reactive properties `href` and `label`.  \
The example is inlining the templates with the ViewModel component inside the same `.jsq` file. This is handy to quickly design components, but we recommend to separate templates from javascript code in production code.

**Example:**

```javascript
import Qute from '@qutejs/runtime';
import MyLinkTemplate from '@qutejs/my-link.jsq';

// The ViewModel component
@Template(MyLinkTemplate)
class MyLink extends ViewModel {
    @Property(String) href;
    @Property(String) label;
    handleClick() {
        alert('Hello!');
    }
}

export default MyLink;
```

The **component's element name** used in templates is not fixed. Because the name is inferred from the JavaScript identifier of the component instance, you can use any namme you want just by changing the JavaScript identifier. You can even use a component using different names in the same template. Example:

```jsq
// let's create a component using a pure rendering function
function MyComponent() {
    const span = document.createElement('SPAN');
    span.textContent = "Hello World!";
    return span;
}
// let's define an alias
const MyComponentAlias = MyComponent;

// let's use the component in a template:
<q:template export>
    <div>
        <MyComponent />
        <MyComponentAlias />
        <!-- or using the kebab case names: -->
        <my-component />
        <my-component-alias />
    </div>
</q:template>
```

In other words, when you design a reusable component you cannot force an element name for the component. The client using your component will be able to use any name it wants to refer to your component.

## The Application Model

As we've seen above **`ViewModel` components** can define a set of properties and some logic to use when rendering the component.

The properties of a component are used to store the component internal state. These properties are reflecting the state of the component instance and not of the application. That's fine, but when you build applications you always need to store some global state which is shared between different components, and which may change the internal state of a component.

Let's say you build the login logic for an application. You want to display in the header a login button when the user is not logged, otherwise you want to replace the button with an user dropdown menu. The information that the current user is logged in or not should be globally available for the components in the application. The login button component should not store this information. Neither the user profile dropdown component.

The information should stored at the application level. It is part of the application data model which is visible to any interested component. Also the service providing the login flow which will update the applciation login status is not hardcoded in some UI components but is part of the application logic and should be defined at application level.

The **Application Model** provides the business logic and a data model visible to all components in the presentation layer.

If a component is interested in some application property (like for example the login state) you can reference the application property from a component using `Link` type properties. These component properties acts like a proxy to the application property: if you set the component property the linked application property will be updated, and vice-versa if some other component change the application property, the linked component property will change too and the component DOM updated (since the `Link` property is a reactive property. In fact a `Link` property value is only stored at application level.

The application data model and services are all provided by an **application instance** which is a singleton in a Qute application. The application instance is passed as an argument to the root `ViewModel` component constructor, which will pass it to all the children components. Thus, the application instance is accessible from any **`ViewModel` component** through a component property named `$app`.

**Note** that if the application instance is not provided to the root component then an implicit one will be created by the component.

As for the `ViewModel` components, you can use JavaScript **classes and decorators** to define the application instance and the application services (although an ES5 API is also available):


```jsq
import window from '@qutejs/window';
import Qute from '@qutejs/runtime';
import qSpinner from '@qutejs/spinner';

const {ViewModel, Template, Link, Service, AsyncDataModel, DataModel, View, Application} = Qute;

<q:template name='RootTemplate'>
	<if value='user'>
		<div style='display:inline-block'>Hello {{user}}!</div>
		<button @click='session.logout()'>Logout</button>
	<else/>
		<q:spinner size='8px' inline q:show='loginPending' />
		<button @click='session.login("Foo")' q:toggle-disabled={loginPending}>Login</button>
	</if>
</q:template>

@Template(RootTemplate)
class RootComponent extends ViewModel {
    @Link('Session/user') user;
    @Link('Session/user/pending') loginPending;
    @Link('Session') session;
}

class SessionManager extends Service {
    @AsyncDataModel('Session/user') user; // publish the user as an async application property

	login(user) {
		// simulate an async login action
		this.user = new Promise((resolve, reject) => {
			window.setTimeout(() => { resolve(user) }, 1000);
		});
	}

	logout() {
		this.user = null;
	}
}

@View(RootComponent) // bind the application to the root component
class MyApp extends Application {
    @DataModel('Session') // publish the session manager inn the application data model as the property 'Session'
    session = new SessionManager(this);
}

new MyApp().mount('app');
```

For more on the application model check the **[Application Instance](#/app/instance)** section.


<!--
------

Let's analyse, how templates works and can help you to reuse similar HTML fragments.

First, a template take as input a parametrized HTML fragment - the fragment you want to reuse. Then, the template is processed in a given context to produce the HTML content you want to put in your page. The context inw hich a template is processed should provide some **data model** to be used to resolve template parameters.

We can see, there are three steps in order to use a template to render some HTML.

1. Define the reusable HTML fragment using some specialy defined syntax.
2. Compile this reusable fragment into something (let's name it a compiled template) that will output DOM elements when invoked given a data model.
3. Invoke the compiled template from other templates or from javascript code.
-->