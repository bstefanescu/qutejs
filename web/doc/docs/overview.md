# Overview

A Qute application is composed of two layers:

1. The presentation layer - also known as the **Component Model**
2. The application layer - also known as the **Application Model**

When developing basic UI components you will mostly use the **presentation layer**. And you can completely ignore the **application layer**.  \
When developing more complex components or javascript applications you will need to focus more on the application layer (i.e. **business logic and data**), and less on individual components composing the presentation layer.

The **goal** of Qute is to let you **focus where you need to**. Qute model try to be as concise as possible in order to hide from you repetitive and glue code.  \
So, you finally write less code and focus more on the business logic.


## The Component Model

When writing web sites one of the most repetitive, annoying and time consuming tasks is to write a lot of similar HTML fragments. To address this, you usually use some template engine, to be able to package these similar HTML fragments as reusable blocks, usually known as **HTML templates**.

### Qute Templates

A template won't be so useful to render some static content. You usually want to parametrize the template content so that, when rendering the template in a specified context, the content will be different depending on that context.

The context in which a template is rendered is providing a **data model** to the template, to resolve the parameters it contains.

Technically, a **template** is a **rendering function** which will generate some HTML given a **rendering context**.  \
You can create templates by simply writing a rendering function from scratch. In some edge cases, you may want to do that.But this is not the intent of templates. A template should be as easy to write as an HTML fragment. Templates are usually defined using HTML with some additional constructs which is known as the **template language**. The template rendering function will be generated by using a **template compiler**.

Some templates are complex, they not only require some **data model** from the rendering context to resolve template parameters, they also need to define some custom logic. **ViewModel Components** are introduced to solve these cases: a **ViewModel component** defines both the template and the rendering context.

In Qute the **template language** name is **`JSQ`**. `JSQ` provides built-in tag and attribute directives like `<for>`, `<if>`, `<a q:show={isVisible}>`, curly braces for attribute expressions and double curly braces (aka mustached) for content expressions. Example:

```jsq-norun
<a href={href} q:show={isVisible}>{{label}}</a>
```

### Qute Components

As we've seen above, in Qute we have 3 **renderable** entities which make up the **Qute Component Model**:

+ **Pure rendering functions**
+ **Templates**
+ **ViewModel Components**

Any of these three entities can be referenced in Qute templates. We will refer to these entities, as **Qute components**.

Thus, Qute **components** are JavaScript functions or object instances that can be referenced as **custom elements** inside Qute **templates**.

#### The Component's Element Name

The name of a custom element refering to a Qute component is inferred from the component javascript identifier. You can use for the custom element name either the (case sensitive) **javascript identifier** as is, either use its **kebab case** equivalent.

To avoid conflicts with existing (or future) HTML elements the Qute component identifiers must contains **at least an uppercase letter** (i.e. either **camel case** or **pascal case** names). Examples: `myButton`, `MyButton`.

If you prefer to use **HTML compliant** element names you can convert pascal case identifiers to kebab case names. Example: `MyButton` to `my-button`. If the identifier is in camel case (starts with a lowercase letter) then the first kebab name segment becomes the element prefix. Example: `myButton` to `my:button`.  \
Identifiers in pascal case name can use the default prefix **`c:`** (`c` from component).

**Examples:**

+ The identifier `myPrimaryButton` can be used in templates either as `<myPrimaryButton>` or as `<my:primary-button>`.
+ The identifier `MyPrimaryButton` can be used in templates either as `<MyPrimaryButton>`, either as `<my-primary-button>`.or as `<c:my-primary-button>`.
+ The identifier `Button` can be used in templates either as `<Button>` or as `<c:button>`.

**Note:** For the rest of the documentation we will mostly use the **kebab case** notation for component element names.

Let's see an example of each type of a Qute component:

#### Pure Rendering functions

```jsq
// the pure rendering function component
function AboutLink(ctx) {
    var link = document.createElement('A');
    link.textContent = 'About';
    link.href = '#about';
    return link;
}

// the root component
<q:template export>
    <div>
        <div>Using identifier case: <AboutLink /></div>
        <div>Using kebab case: <about-link /></div>
    </div>
</q:template>
```

#### Templates

Templates are rendering functions generated from an HTML like fragment by the Qute compiler. Template are declared inside `.jsq` (or `.qute`) files and should be enclosed in a `<q:template>` tag:

```jsq
// The MyLink component
<q:template name='MyLink'>
    <a href={href}>{{$attrs.label}}</a>
</q:template>

// The root component
<q:template export>
    <div>
        <div>Using identifier case: <MyLink href='about' label='About'/></div>
        <div>Using kebab case: <my-link href='about' label='About'/></div>
    </div>
</q:template>
```

#### ViewModel Components

ViewModel components will link a template (or a pure rendering function) to a rendering context (i.e. rendering data model and logic).

ViewModel components can be declared in the same `.jsq` file as the linked template or in a regular javascript file and then importing the template via a javascript `import` statement.

```jsq
import Qute from '@qutejs/runtime';

// The MyLink template
<q:template name='MyLinkTemplate'>
    <a href={href} @click='handleClick'>{{label}}</a>
</q:template>

// The ViewModel component
const MyLink = Qute(MyLinkTemplate, {
    handleClick() {
        alert('Hello!');
    }
}).properties({
    href: null,
    label: null
});

// The root component
<q:template export>
    <div>
        <div>Using identifier case: <MyLink href='about' label='About'/></div>
        <div>Using kebab case: <my-link href='about' label='About'/></div>
    </div>
</q:template>
```

The above exmaple is inlining the templates with the ViewModel component inside the same `.jsq` file. This is handy to quickly design components, but we recommend to separate templates from javascript code in production code.

**Example:**

```javascript
import Qute from '@qutejs/runtime';
import MyLinkTemplate from '@qutejs/my-link.jsq';

// The ViewModel component
export default Qute(MyLinkTemplate, {
    handleClick() {
        alert('Hello!');
    }
}).properties({
    href: null,
    label: null
});
```

The component's element name used in templates is not fixed. Because it is inferred from the JavaScript identifier of the component instance, you can use any namme you want just by changing the JavaScript identifier. You can even use a component using different names in the same template. Example:

```jsq
// let's create a component using a pure rendering function
function MyComponent() {
    const span = document.createElement('SPAN');
    span.textContent = "Hello World!";
    return span;
}
// let's define an alias
const MyComponentAlias = MyComponent;

// let's use the component in a template:
<q:template export>
    <div>
        <MyComponent />
        <MyComponentAlias />
        <!-- or using the kebab case names: -->
        <my-component />
        <my-component-alias />
    </div>
</q:template>
```

In other words, when you design a reusable component you cannot force an element name for the component. The client using your component will be able to use any name it wants in templates to refer to your component.

## The Application Model

As we've seen above **`ViewModel` components** can define a set of properties and some logic to use when rendering the component.

The properties of a component are used to store the component internal state. These properties are reflecting the state of the component instance and not of the application. That's fine, but when you build applications you always need to store some global state which is shared between different components, and which may change the internal state of a component.

Let's say you build the login logic for an application. You want to display in the header a login button when the user is not logged, othewrwise you want to replace the button with some user profile dropdown menu. The information that the current user is logged in or not should be globally available for the components in the application. The login button component should not store this information. Neither the user profile dropdown component.

The information should stored at the application level. It is part of the application data model which is visible to any interested component. Also the service providing the login flow which will update the applciation login status is not hardcoded in some UI components but is part of the application logic and should be defined at application level.

The **Application Model** provides the business logic and a shared data model visible to any interested component.

If a component is interested in some application property (like for example the login state) you can link the application property to a component property. Changing such a linked component property will automatically update the application property an viceversa. In fact the property value is only stored at application level. See the `_Link` property type in the **[Property Types section](#/model/proptypes)** and the **[Application Data Model Example](#/app/example)** for more details on linked properties.

The application data model and services are all provided by an **application instance** which is a singleton in a Qute application. The application instance is accessible from any **`ViewModel` component**.

For more about the application model check the **[Application Instance](#/app/instance)** section.


<!--
------

Let's analyse, how templates works and can help you to reuse similar HTML fragments.

First, a template take as input a parametrized HTML fragment - the fragment you want to reuse. Then, the template is processed in a given context to produce the HTML content you want to put in your page. The context inw hich a template is processed should provide some **data model** to be used to resolve template parameters.

We can see, there are three steps in order to use a template to render some HTML.

1. Define the reusable HTML fragment using some specialy defined syntax.
2. Compile this reusable fragment into something (let's name it a compiled template) that will output DOM elements when invoked given a data model.
3. Invoke the compiled template from other templates or from javascript code.
-->